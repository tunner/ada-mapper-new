#!/usr/bin/env python3
"""
Minimal mapper generator (MVP sketch).

Reads mappings.json and emits a simple Ada package with
overloaded Map functions that map fields using Convert(...).

Assumptions (kept simple on purpose):
- Source types live in package `Types_From` (src/types_from.ads).
- Destination types live in package `Types_To` (src/types_to.ads).
- JSON lists mappings with `from`, `to`, `fields`.
- We generate files: src/position_mappers.ads and src/position_mappers.adb

Usage:
  python3 tools/gen_mapper.py [mappings.json] [outdir]
Defaults:
  mappings.json
  outdir = src
"""
from __future__ import annotations

import argparse
import json
import subprocess
import sys
from pathlib import Path
from records import parse_record_components
from arrays import parse_array_component_type, array_map_spec, array_map_body
from generator import MapperGenerator


SPEC_TEMPLATE_HEADER = """with Types_From;
with Types_To;

package Position_Mappers is
   --  Generated by tools/gen_mapper.py — DO NOT EDIT.
"""

SPEC_TEMPLATE_FOOTER = """
end Position_Mappers;
"""


BODY_TEMPLATE_HEADER = """with Types_From; use Types_From;
with Types_To;   use Types_To;

package body Position_Mappers is
   --  Generated by tools/gen_mapper.py — DO NOT EDIT.
"""

BODY_TEMPLATE_FOOTER = """
end Position_Mappers;
"""


def gen_function_spec(src_type: str, dst_type: str) -> str:
    return f"   function Map (X : Types_From.{src_type}) return Types_To.{dst_type};\n"


def _gen_with_class(mg: MapperGenerator, src_type: str, dst_type: str, fields: dict[str, str]) -> str:
    return mg.gen_record_function_body(src_type, dst_type, fields)


def run_compile(outdir: Path) -> int:
    """Compile the generated mapper to validate syntax using gnatmake only.

    Returns the subprocess return code. If gnatmake is not found, returns 127.
    """
    mapper = outdir / "position_mappers.adb"
    cmd = ["gnatmake", "-q", "-c", f"-I{outdir}", str(mapper)]
    try:
        res = subprocess.run(cmd, capture_output=True, text=True)
    except FileNotFoundError:
        sys.stderr.write(
            "Validation failed: gnatmake not found on PATH. Please install GNAT and ensure 'gnatmake' is available.\n"
        )
        return 127
    if res.returncode == 0:
        print("Validation: mapper compiles.")
    else:
        sys.stderr.write(res.stdout)
        sys.stderr.write(res.stderr)
    return res.returncode


def main():
    parser = argparse.ArgumentParser(description="Generate Ada mappers from JSON.")
    parser.add_argument("mappings", nargs="?", default="mappings.json", help="Path to mappings.json")
    parser.add_argument("outdir", nargs="?", default="src", help="Output directory (default: src)")
    parser.add_argument("--validate", action="store_true", help="Compile generated mapper to validate syntax")
    args = parser.parse_args()

    mappings_path = Path(args.mappings)
    outdir = Path(args.outdir)

    spec_path = outdir / "position_mappers.ads"
    body_path = outdir / "position_mappers.adb"

    data = json.loads(mappings_path.read_text())
    mappings = data.get("mappings", [])
    if not mappings:
        print("No mappings found in", mappings_path)
        sys.exit(1)

    # Build spec and body content
    spec_parts = [SPEC_TEMPLATE_HEADER]
    body_parts = [BODY_TEMPLATE_HEADER]

    # Resolve type spec locations relative to output directory
    types_from_ads = Path(outdir) / "types_from.ads"
    types_to_ads = Path(outdir) / "types_to.ads"
    mg = MapperGenerator(types_from_ads, types_to_ads, set())

    # Build a set of known mapping type pairs for nested delegation
    mg.mapping_pairs = set(
        (m.get("from"), m.get("to")) for m in mappings if m.get("from") and m.get("to")
    )

    for m in mappings:
        src_type = m["from"]
        dst_type = m["to"]
        fields = m["fields"]

        spec_parts.append(gen_function_spec(src_type, dst_type))
        body_parts.append(_gen_with_class(mg, src_type, dst_type, fields))

    # Expand array mapping pairs transitively for nested arrays
    mg.expand_array_pairs_transitively()

    # Add Map specs for detected array pairs
    for src_arr, dst_arr in sorted(mg.needed_array_maps):
        spec_parts.append(array_map_spec(src_arr, dst_arr))

    # Emit array Map bodies (element-wise mapping with recursion)
    for src_arr, dst_arr in sorted(mg.needed_array_maps):
        body_parts.append(array_map_body(mg, src_arr, dst_arr))
    spec_parts.append(SPEC_TEMPLATE_FOOTER)
    body_parts.append(BODY_TEMPLATE_FOOTER)

    outdir.mkdir(parents=True, exist_ok=True)
    spec_path.write_text("".join(spec_parts))
    body_path.write_text("".join(body_parts))

    print(f"Wrote {spec_path}")
    print(f"Wrote {body_path}")

    if args.validate:
        code = run_compile(outdir)
        if code != 0:
            sys.exit(code)


if __name__ == "__main__":
    main()
